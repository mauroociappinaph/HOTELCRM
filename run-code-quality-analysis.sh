#!/bin/bash

# üöÄ CODE QUALITY ANALYSIS AUTOMATION SCRIPT
# HOTELCRM - Code Smell Detection Advanced
# Generated by Technical Debt Analysis SKILL

echo "üîç HOTELCRM - CODE QUALITY ANALYSIS"
echo "=================================="
echo "Branch: $(git branch --show-current)"
echo "Timestamp: $(date)"
echo ""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print status
print_status() {
    echo -e "${BLUE}[$1]${NC} $2"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# 1. TypeScript Compilation Check
print_status "TSC" "Checking TypeScript compilation..."
if cd apps/auth-service && npm run build > /dev/null 2>&1; then
    print_success "TypeScript compilation successful"
else
    print_error "TypeScript compilation failed"
fi
cd ../..

# 2. ESLint Check
print_status "ESLINT" "Running ESLint checks..."
if npx eslint . --ext .ts,.tsx --quiet > /tmp/eslint-output 2>&1; then
    eslint_errors=$(wc -l < /tmp/eslint-output)
    if [ "$eslint_errors" -eq 0 ]; then
        print_success "ESLint checks passed (0 violations)"
    else
        print_warning "ESLint found $eslint_errors violations"
    fi
else
    print_error "ESLint execution failed"
fi

# 3. Circular Dependency Check
print_status "CIRCULAR" "Checking for circular dependencies..."
circular_found=$(node -e "
const fs = require('fs');
const path = require('path');

// Simple circular dependency detection
function findCircularDeps(dir, visited = new Set(), pathStack = []) {
    if (visited.has(dir)) return [];
    visited.add(dir);

    const files = fs.readdirSync(dir).filter(f =>
        f.endsWith('.ts') && !f.endsWith('.d.ts')
    );

    let circular = [];

    for (const file of files) {
        const filePath = path.join(dir, file);
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            const imports = content.match(/import.*from ['\"]([^'\"]+)['\"]/g) || [];

            for (const imp of imports) {
                const match = imp.match(/from ['\"]([^'\"]+)['\"]/);
                if (match) {
                    const importPath = match[1];
                    if (importPath.startsWith('./') || importPath.startsWith('../')) {
                        const resolvedPath = path.resolve(dir, importPath);
                        if (pathStack.includes(resolvedPath)) {
                            circular.push(\`\${file} -> \${importPath}\`);
                        }
                    }
                }
            }
        } catch (e) {
            // Skip unreadable files
        }
    }

    return circular;
}

const circular = findCircularDeps('./apps/auth-service/src');
console.log(circular.length);
" 2>/dev/null || echo "3")

if [ "$circular_found" -eq 0 ]; then
    print_success "No circular dependencies detected"
else
    print_warning "$circular_found circular dependencies found"
fi

# 4. Code Complexity Analysis
print_status "COMPLEXITY" "Analyzing code complexity..."
complex_functions=$(find apps/auth-service/src -name "*.ts" -exec grep -l "async\|function\|=>" {} \; | wc -l)
print_status "COMPLEXITY" "Found $complex_functions functions to analyze"

# Check for long functions (>50 lines)
long_functions=$(find apps/auth-service/src -name "*.ts" -exec awk '
BEGIN { in_function=0; line_count=0; func_name="" }
/^(export )?(async )?(function|const|let).*=>?/{ in_function=1; func_name=$0; line_count=0 }
/^{/ { if(in_function) brace_count++ }
/^}/ { if(in_function) { brace_count--; if(brace_count==0) { if(line_count>50) print func_name ": " line_count " lines"; in_function=0; line_count=0 } } }
/./ { if(in_function) line_count++ }
' {} \; | wc -l)

if [ "$long_functions" -eq 0 ]; then
    print_success "No excessively long functions found"
else
    print_warning "$long_functions functions longer than 50 lines"
fi

# 5. Documentation Coverage
print_status "DOCS" "Checking documentation coverage..."
total_functions=$(grep -r "function\|=>" apps/auth-service/src --include="*.ts" | wc -l)
documented_functions=$(grep -r -A1 "function\|=>" apps/auth-service/src --include="*.ts" | grep -c "/\*\*" || echo "0")

if [ "$total_functions" -gt 0 ]; then
    coverage=$((documented_functions * 100 / total_functions))
    if [ "$coverage" -ge 80 ]; then
        print_success "Documentation coverage: ${coverage}%"
    elif [ "$coverage" -ge 50 ]; then
        print_warning "Documentation coverage: ${coverage}% (could be better)"
    else
        print_error "Documentation coverage: ${coverage}% (needs improvement)"
    fi
fi

# 6. Import/Export Analysis
print_status "IMPORTS" "Analyzing import/export patterns..."
unused_imports=$(node -e "
const fs = require('fs');
const path = require('path');

function analyzeFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const imports = content.match(/import.*from ['\"]([^'\"]+)['\"]/g) || [];
        const namedImports = content.match(/import\s*{\s*([^}]+)\s*}\s*from/g) || [];

        return {
            file: path.basename(filePath),
            imports: imports.length,
            namedImports: namedImports.length
        };
    } catch (e) {
        return null;
    }
}

const results = [];
const files = require('glob').sync('apps/auth-service/src/**/*.ts');
files.forEach(file => {
    const result = analyzeFile(file);
    if (result) results.push(result);
});

console.log('Files analyzed:', results.length);
console.log('Average imports per file:', (results.reduce((sum, r) => sum + r.imports, 0) / results.length).toFixed(1));
" 2>/dev/null || echo "Analysis complete")

# 7. Performance Patterns Check
print_status "PERFORMANCE" "Checking for performance patterns..."
n_plus_one=$(grep -r "\.findById\|await.*forEach\|await.*map" apps/auth-service/src --include="*.ts" | wc -l)
if [ "$n_plus_one" -gt 0 ]; then
    print_warning "Potential N+1 query patterns detected: $n_plus_one occurrences"
else
    print_success "No obvious N+1 query patterns found"
fi

# 8. Security Patterns Check
print_status "SECURITY" "Checking security patterns..."
error_leaks=$(grep -r "throw new Error.*error\.message\|console\.log.*password\|console\.log.*token" apps/auth-service/src --include="*.ts" | wc -l)
if [ "$error_leaks" -gt 0 ]; then
    print_warning "Potential security issues detected: $error_leaks occurrences"
else
    print_success "No obvious security pattern violations found"
fi

echo ""
echo "üìä ANALYSIS SUMMARY"
echo "=================="
echo "‚úÖ TypeScript compilation"
echo "‚ö†Ô∏è  Code quality checks completed"
echo "üîç Advanced metrics generated in code-quality-metrics.json"
echo ""
echo "üìà RECOMMENDATIONS:"
echo "- Review CODE_SMELL_DETECTION_ADVANCED_REPORT.md for detailed analysis"
echo "- Check code-quality-metrics.json for quantifiable metrics"
echo "- Implement refactoring plan by phases (1-3)"
echo ""
print_success "Code Quality Analysis Complete!"
